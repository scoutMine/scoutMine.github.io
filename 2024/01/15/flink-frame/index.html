<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Flink运行时架构 | SHENFY BLOG</title><meta name="author" content="Shen Fengyin"><meta name="copyright" content="Shen Fengyin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Flink运行时架构 本文主要介绍Flink的架构，涉及具体源码请移步源码解析。一句话总结——Flink是一个分布式的并行流处理系统。  Flink作为如今最为热门的流处理框架，从批处理到Lambda架构再到Flink的问世，对比总结Flink的优点无非以下几点：  高吞吐和低延迟。每秒处理数百万个事件，毫秒级延迟。  结果的准确性。Flink 提供了事件时间（event-time）和处理时间（p">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink运行时架构">
<meta property="og:url" content="http://shenfenyin.github.io/2024/01/15/flink-frame/index.html">
<meta property="og:site_name" content="SHENFY BLOG">
<meta property="og:description" content="Flink运行时架构 本文主要介绍Flink的架构，涉及具体源码请移步源码解析。一句话总结——Flink是一个分布式的并行流处理系统。  Flink作为如今最为热门的流处理框架，从批处理到Lambda架构再到Flink的问世，对比总结Flink的优点无非以下几点：  高吞吐和低延迟。每秒处理数百万个事件，毫秒级延迟。  结果的准确性。Flink 提供了事件时间（event-time）和处理时间（p">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://shenfenyin.github.io/img/sfy_portriat.jpg">
<meta property="article:published_time" content="2024-01-14T16:51:57.843Z">
<meta property="article:modified_time" content="2024-01-14T18:44:26.708Z">
<meta property="article:author" content="Shen Fengyin">
<meta property="article:tag" content="Flink">
<meta property="article:tag" content="分布式架构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://shenfenyin.github.io/img/sfy_portriat.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://shenfenyin.github.io/2024/01/15/flink-frame/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Flink运行时架构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-15 02:44:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/sfy_portriat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 近期博客</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 相关</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="SHENFY BLOG"><span class="site-name">SHENFY BLOG</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 近期博客</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 相关</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Flink运行时架构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-14T16:51:57.843Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-14T18:44:26.708Z" title="更新于 2024-01-15 02:44:26">2024-01-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Flink/">Flink</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Flink运行时架构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Flink运行时架构"><a href="#Flink运行时架构" class="headerlink" title="Flink运行时架构"></a>Flink运行时架构</h1><blockquote>
<p>本文主要介绍Flink的架构，涉及具体源码请移步源码解析。一句话总结——<strong>Flink是一个分布式的并行流处理系统</strong>。</p>
</blockquote>
<p>Flink作为如今最为热门的流处理框架，从批处理到Lambda架构再到Flink的问世，对比总结Flink的优点无非以下几点：</p>
<ul>
<li><p><strong>高吞吐和低延迟</strong>。每秒处理数百万个事件，毫秒级延迟。</p>
</li>
<li><p>结果的准确性。Flink 提供了事件时间（event-time）和处理时间（processing-time）语义。对于乱序事件流，事件时间语义仍然能提供一致且准确的结果。</p>
</li>
<li><p><strong>精确一次（exactly-once）的状态一致性保证。</strong></p>
</li>
<li><p>可以连接到最常用的存储系统，如 Apache Kafka、Apache Cassandra、Elasticsearch、JDBC、Kinesis 和（分布式）文件系统，如 HDFS 和 S3。</p>
</li>
<li><p>高可用。本身高可用的设置，<strong>加上与 K8s，YARN 和 Mesos 的紧密集成</strong>，再加上从故障中快速恢复和动态扩展任务的能力，Flink 能做到以极少的停机时间 7×24 全天候运行。</p>
</li>
<li><p>能够更新应用程序代码并将作业（jobs）迁移到不同的 Flink 集群，而不会丢失应用程序的状态。（待。。。</p>
</li>
</ul>
<h2 id="一、-Flink系统架构"><a href="#一、-Flink系统架构" class="headerlink" title="一、 Flink系统架构"></a>一、 Flink系统架构</h2><p><img src="/2024/01/15/flink-frame/image-20231216224323919.png" alt="image-20231216224323919"></p>
<center>图1：Flink作业提交和任务处理系统</center>

<p>​		这里首先要说明一下“客户端”。<strong>其实客户端并不是处理系统的一部分，它只负责作业的提交。</strong>具体来说，就是调用程序的 main 方法，<strong>将代码转换成“数据流图”（Dataflow Graph），并最终生成作业图（JobGraph），一并发送给 JobManager</strong>。提交之后，任务的执行其实就跟客户端没有关系了；我们可以在客户端选择断开与 JobManager 的连接, 也可以继续保持连接。之前我们在命令提交作业时，加上的-d 参数，就是表示分离模式（detached mode)，也就是断开连接。</p>
<p>​		当然，客户端可以随时连接到 JobManager，获取当前作业的状态和执行结果，也可以发送请求取消作业。不论通过 Web UI 还是命令行执行“flink run”的相关操作，都是通过客户端实现的。</p>
<p>JobManager 和 TaskManagers 可以以不同的方式启动：</p>
<ol>
<li><p>作为独立（Standalone）集群的进程，直接在机器上启动</p>
</li>
<li><p>在容器中启动</p>
</li>
<li><p>由资源管理平台调度启动，比如 YARN、K8S</p>
</li>
</ol>
<p>​		这其实就对应着不同的部署方式。TaskManager 启动之后，JobManager 会与它建立连接，并将作业图（JobGraph）转换成可执行的“执行图”（ExecutionGraph）分发给可用的 TaskManager，然后就由 TaskManager 具体执行任务。</p>
<p>​		上面的Flink作业提交和任务处理系统图只做一个简单的介绍，对于JobManager、JobMaster、TaskManager、ResourceManager、Dispatcher下面做简单介绍，详细介绍在源码解析中。</p>
<h3 id="1-1-作业管理器（JobManager）"><a href="#1-1-作业管理器（JobManager）" class="headerlink" title="1.1 作业管理器（JobManager）"></a>1.1 作业管理器（JobManager）</h3><p>​		JobManager 是一个 Flink 集群中任务管理和调度的核心，是<strong>控制应用执行的主进程</strong>。也就是说，每个应用都应该被唯一的 JobManager 所控制执行。</p>
<p>​		当然，在高可用（HA）的场景下，可能会出现多个 JobManager；这时只有一个是正在运行的领导节点（leader），其他都是备用节点（standby）。JobManger 又包含 3 个不同的组件，下面我们一一讲解：</p>
<ol>
<li>JobMaster</li>
</ol>
<p>​		<strong>JobMaster 是 JobManager 中最核心的组件，负责处理单独的作业（Job）</strong>。所以 JobMaster和具体的 Job 是一一对应的，多个 Job 可以同时运行在一个 Flink 集群中, 每个 Job 都有一个自己的 JobMaster。需要注意在早期版本的 Flink 中，没有 JobMaster 的概念；而 JobManager的概念范围较小，实际指的就是现在所说的 JobMaster。</p>
<p>​		<strong>在作业提交时，JobMaster 会先接收到要执行的应用。这里所说“应用”一般是客户端提交来的，包括：Jar 包，数据流图（dataflow graph），和作业图（JobGraph）（sql呢？？？。</strong>JobMaster 会把 JobGraph 转换成一个物理层面的数据流图，这个图被叫作“执行图”（ExecutionGraph），它包含了所有可以并发执行的任务。</p>
<p>​		 JobMaster 会向资源管理器（ResourceManager）发出请求，申请执行任务必要的资源。<strong>一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的 TaskManager 上。</strong></p>
<p>​		而在运行过程中，JobMaster 会负责所有需要中央协调的操作，比如说检查点（checkpoints）的协调。</p>
<ol start="2">
<li>资源管理器（ResourceManager）</li>
</ol>
<p>​		ResourceManager 主要负责资源的分配和管理，在 Flink 集群中只有一个。所谓“资源”，主要是指 TaskManager 的任务槽（task slots）。任务槽就是 Flink 集群中的资源调配单元，包含了机器用来执行计算的一组 CPU 和内存资源。<strong>每一个任务（Task）都需要分配到一个 slot 上执行。</strong>（这里注意task可以空间上共享slot，类似并发）</p>
<p>​		这里注意要把 Flink 内置的 ResourceManager 和其他资源管理平台（比如 YARN）的ResourceManager 区分开。Flink 的 ResourceManager，针对不同的环境和资源管理平台（比如 Standalone 部署，或者YARN），有不同的具体实现。在 Standalone 部署时，因为 TaskManager 是单独启动的（没有Per-Job 模式），所以 ResourceManager 只能分发可用 TaskManager 的任务槽，不能单独启动新TaskManager。</p>
<p>​		而在有资源管理平台时，就不受此限制。当新的作业申请资源时，ResourceManager 会将有空闲槽位的 TaskManager 分配给 JobMaster。如果 ResourceManager 没有足够的任务槽，它还可以向资源提供平台发起会话，请求提供启动 TaskManager 进程的容器。另外，ResourceManager 还负责停掉空闲的 TaskManager，释放计算资源。</p>
<ol start="3">
<li><p>分发器（Dispatcher）</p>
<blockquote>
<ol>
<li>接受用户作业 2. 启动jobMaster</li>
</ol>
</blockquote>
</li>
</ol>
<p>​		<strong>Dispatcher 主要负责提供一个 REST 接口，用来提交应用，并且负责为每一个新提交的作业启动一个新的 JobMaster 组件</strong>。Dispatcher 也会启动一个 Web UI，用来方便地展示和监控作业执行的信息。<strong>Dispatcher 在架构中并不是必需的</strong>，在不同的部署模式下可能会被忽略掉。</p>
<h3 id="1-2-任务管理器（TaskManager）"><a href="#1-2-任务管理器（TaskManager）" class="headerlink" title="1.2 任务管理器（TaskManager）"></a>1.2 任务管理器（TaskManager）</h3><p>​		<strong>TaskManager 是 Flink 中的工作进程，数据流的具体计算就是它来做的，所以也被称为“Worker”</strong>。Flink 集群中必须至少有一个 TaskManager；当然由于分布式计算的考虑，通常会有多个 TaskManager 运行，每一个 TaskManager 都包含了一定数量的任务槽（task slots）。<strong>Slot是资源调度的最小单位，slot 的数量限制了 TaskManager 能够并行处理的任务数量。</strong></p>
<p>​		启动之后，TaskManager 会向资源管理器注册它的 slots；<strong>收到资源管理器的指令后，TaskManager 就会将一个或者多个槽位提供给 JobMaster 调用，JobMaster 就可以分配任务来执行了。</strong>在执行过程中，TaskManager 可以缓冲数据，还可以跟其他运行同一应用的 TaskManager交换数据。</p>
<h2 id="二、-Flink作业提交流程"><a href="#二、-Flink作业提交流程" class="headerlink" title="二、 Flink作业提交流程"></a>二、 Flink作业提交流程</h2><p>Flink作业根据部署模式、资源管理平台的不同，有不同的作业提交流程，首先介绍下抽象的流程：</p>
<h3 id="2-1-抽象作业提交流程"><a href="#2-1-抽象作业提交流程" class="headerlink" title="2.1 抽象作业提交流程"></a>2.1 抽象作业提交流程</h3><p><img src="/2024/01/15/flink-frame/image-20231216233932729.png" alt="image-20231216233932729"></p>
<center>Flink作业提交流程</center>

<p>（1） 一般情况下，由客户端（App）通过分发器提供的 REST 接口，将作业提交给JobManager。</p>
<p>（2）由分发器启动 JobMaster，并将作业（包含 JobGraph）提交给 JobMaster。</p>
<p>（3）<strong>JobMaster 将 JobGraph 解析为可执行的 ExecutionGraph</strong>，得到所需的资源数量，然后向资源管理器请求资源（slots）。</p>
<p>（4）资源管理器判断当前是否由足够的可用资源；如果没有，启动新的 TaskManager。</p>
<p>（5）TaskManager 启动之后，向 ResourceManager 注册自己的可用任务槽（slots）。</p>
<p>（6）资源管理器通知 TaskManager 为新的作业提供 slots。</p>
<p>（7）TaskManager 连接到对应的 JobMaster，提供 slots。</p>
<p>（8）JobMaster 将需要执行的任务分发给 TaskManager。</p>
<p>（9）TaskManager 执行任务，互相之间可以交换数据。</p>
<p>​		如果部署模式不同，或者集群环境不同（例如 Standalone、YARN、K8S 等），其中一些步骤可能会不同或被省略，也可能有些组件会运行在同一个 JVM 进程中。比如我们在上一章实践过的独立集群环境的会话模式，就是需要先启动集群，如果资源不够，只能等待资源释放，而不会直接启动新的 TaskManager。</p>
<h3 id="2-2-yarn集群部署模式"><a href="#2-2-yarn集群部署模式" class="headerlink" title="2.2 yarn集群部署模式"></a>2.2 yarn集群部署模式</h3><p>下面两张图对比独立模式和yarn集群的区别，其实主要就是资源分配的区别：</p>
<p><img src="/2024/01/15/flink-frame/image-20231217000352858.png" alt="image-20231217000352858"></p>
<p><img src="/2024/01/15/flink-frame/image-20231217000418508.png" alt="image-20231217000418508"></p>
<p>​		在<strong>独立模式</strong>（Standalone）下，只有<strong>会话模式和应用模式</strong>两种部署方式。两者整体来看流程是非常相似的：<strong>TaskManager 都需要手动启动，所以当 ResourceManager 收到 JobMaster 的请求时，会直接要求 TaskManager 提供资源。</strong>而 JobMaster 的启动时间点，会话模式是预先启动，应用模式则是在作业提交时启动。</p>
<p><strong>yarn集群会话</strong>（session）模式：</p>
<p>（1）客户端通过 REST 接口，将作业提交给分发器。</p>
<p>（2）分发器启动 JobMaster，并将作业（包含 JobGraph）提交给 JobMaster。</p>
<p>（3）JobMaster 向资源管理器请求资源（slots）。</p>
<p>（4）资源管理器向 YARN 的资源管理器请求 container 资源。</p>
<p>（5）<strong>YARN 启动新的 TaskManager 容器</strong>。</p>
<p>（6）TaskManager 启动之后，向 Flink 的资源管理器注册自己的可用任务槽。</p>
<p>（7）资源管理器通知 TaskManager 为新的作业提供 slots。</p>
<p>（8）TaskManager 连接到对应的 JobMaster，提供 slots。</p>
<p>（9）JobMaster 将需要执行的任务分发给 TaskManager，执行任务。</p>
<p>​		可见，整个流程除了请求资源时要“上报”YARN 的资源管理器，其他与独立模式几乎一样，<strong>yarn会话模式帮助我们管理TM，而不需要我们手动启动TM</strong>。</p>
<p>​		yarn会话模式还有一点需要注意的是：在<strong>会话模式下，我们需要先启动一个 YARN session，这个会话会创建一个 Flink 集群</strong>。</p>
<p><img src="/2024/01/15/flink-frame/image-20231217001306829.png" alt="image-20231217001306829"></p>
<p>​		可以发现刚启动YARN session的时候，JobManager只有ResourceManager和Dispatcher，<strong>并没有JobMaster，因为此时并没有Flink任务提交，自然无需JobMaster调度TM</strong>。同时这里只启动了 JobManager，而 TaskManager 可以根据需要动态地启动（yarn控制？）。</p>
<p><strong>yarn单作业</strong>（per-job）模式：</p>
<p>与session模式最大区别在于——<strong>在单作业模式下，Flink 集群不会预先启动，而是在提交作业时，才启动新的 JobManager</strong>，如图所示：</p>
<p><img src="/2024/01/15/flink-frame/image-20231217002139143.png" alt="image-20231217002139143"></p>
<p>（1）客户端将作业提交给 YARN 的资源管理器，这一步中会同时将 Flink 的 Jar 包和配置</p>
<p>上传到 HDFS，以便后续启动 Flink 相关组件的容器。</p>
<p>（2）YARN 的资源管理器分配 Container 资源，启动 Flink JobManager，并将作业提交给JobMaster。这里省略了 Dispatcher 组件。</p>
<p>（3）JobMaster 向资源管理器请求资源（slots）。</p>
<p>（4）资源管理器向 YARN 的资源管理器请求 container 资源。</p>
<p>（5）YARN 启动新的 TaskManager 容器。</p>
<p>（6）TaskManager 启动之后，向 Flink 的资源管理器注册自己的可用任务槽。</p>
<p>（7）资源管理器通知 TaskManager 为新的作业提供 slots。</p>
<p>（8）TaskManager 连接到对应的 JobMaster，提供 slots。</p>
<p>（9）JobMaster 将需要执行的任务分发给 TaskManager，执行任务。</p>
<p>​		可见，区别<strong>只在于 JobManager 的启动方式，以及省去了分发器</strong>。当第 2 步作业提交给JobMaster，之后的流程就与会话模式完全一样了。</p>
<p>一般互联网用的是pre-job模式？也就是说，每次提交一个 Flink SQL 作业，都会创建一个对应的作业实例，并在 YARN 上分配资源来运行该实例？</p>
<p>使用 per-job 模式的原因包括：</p>
<ol>
<li>资源隔离：每个作业会有自己独立的资源分配，这样可以确保作业之间不会相互影响，提高了资源利用效率。</li>
<li>灵活性和控制：per-job 模式允许每个作业运行时可以独立地配置参数，比如内存分配、并行度等，从而更好地控制每个作业的运行环境。</li>
<li>故障隔离：当一个作业发生故障时，per-job 模式可以确保这个故障不会影响到其他作业，提高了整体系统的稳定性和可靠性。</li>
</ol>
<p>总的来说，per-job 模式可以提供更好的资源隔离、灵活性和故障隔离，使得每个作业可以更加独立地运行和管理。</p>
<p>​        还有一种应用（application）模式，与单作业模式的提交流程非常相似，只是初始提交给 YARN 资源管理器的不再是具体的作业，而是整个应用。一个应用中可能包含了多个作业，这些作业都将在 Flink 集群中启动各自对应的 JobMaster。</p>
<p>​        整体来说，YARN 上部署的过程是：<strong>客户端把 Flink 应用提交给 Yarn 的 ResourceManager, Yarn 的 ResourceManager 会向 Yarn 的 NodeManager 申请容器。在这些容器上，Flink 会部署JobManager 和 TaskManager 的实例，从而启动集群。</strong>Flink 会根据运行在 JobManger 上的作业所需要的 Slot 数量动态分配 TaskManager 资源。 关于NodeManager等信息可以了解下Hadoop架构，待。。。</p>
<h2 id="三、-FLink数据流图"><a href="#三、-FLink数据流图" class="headerlink" title="三、 FLink数据流图"></a>三、 FLink数据流图</h2><blockquote>
<p>介绍Dataflow Graph方便更深入理解所谓“流处理”到底是怎么抽象实现的。</p>
</blockquote>
<p>​		Flink 是流式计算框架。它的程序结构，其实就是定义了一连串的处理操作，每一个数据输入之后都会依次调用每一步计算。在 Flink 代码中，<strong>我们定义的每一个处理转换操作都叫作“算子”（Operator）</strong>，所以我们的程序可以看作是一串算子构成的管道，数据则像水流一样有序地流过。 以wordcount举例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamWordCount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建流式执行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">// 2. 读取文本流</span></span><br><span class="line">        DataStreamSource&lt;String&gt; lineDSS = env.socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>);</span><br><span class="line">        <span class="comment">// 3. 转换数据格式</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; wordAndOne = lineDSS</span><br><span class="line">                .flatMap((String line, Collector&lt;String&gt; words) -&gt; &#123;</span><br><span class="line">                    Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)).forEach(words::collect);</span><br><span class="line">                &#125;)</span><br><span class="line">                .returns(Types.STRING)</span><br><span class="line">                .map(word -&gt; Tuple2.of(word, <span class="number">1L</span>))</span><br><span class="line">                .returns(Types.TUPLE(Types.STRING, Types.LONG));</span><br><span class="line">        <span class="comment">// 4. 分组</span></span><br><span class="line">        KeyedStream&lt;Tuple2&lt;String, Long&gt;, String&gt; wordAndOneKS = wordAndOne</span><br><span class="line">                .keyBy(t -&gt; t.f0);</span><br><span class="line">        <span class="comment">// 5. 求和</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; result = wordAndOneKS</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 6. 打印</span></span><br><span class="line">        result.print();</span><br><span class="line">        <span class="comment">// 7. 执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的 Flink 程序都可以归纳为由三部分构成：Source、Transformation 和 Sink。</p>
<ul>
<li><p>Source 表示“源算子”，负责读取数据源。</p>
</li>
<li><p>transformation 表示“转换算子”，利用各种算子进行处理加工。</p>
</li>
<li><p>Sink 表示“下沉算子”，负责数据的输出。</p>
</li>
</ul>
<p>​		source、sink算子见名知意，transformation算子相对来说就复杂一点。以上面wordcount来看，flatMap、map、sum都是transformation算子。<strong>但是这里的keyBy并不是算子，因为一个中间的转换算子（Transformation Operator）必须是一个转换处理的操作；而在代码中有一些方法调用，数据是没有完成转换的。</strong>可能只是对属性做了一个设置，也可能定义的是数据的传递方式而非转换，又或者是需要几个方法合在一起才能表达一个完整的转换操作。</p>
<p>​		事实上也可以根据返回值的类型判断，可以看出flatMap、map、sum它们的返回值都是Operator类，而keyBy这里是KeyedStream，可以简单看下继承关系：</p>
<p><img src="/2024/01/15/flink-frame/image-20231217010522064.png" alt="image-20231217010522064"></p>
<p>​		可以看出KeyedStream和SingleOutputStreamOperator都是DataStream，而且两个是兄弟关系，KeyedStream不是Operator，关于DataStream API详细可以看Flink DataStream API介绍。 待。。。。。。。。</p>
<h3 id="3-1-并行计算"><a href="#3-1-并行计算" class="headerlink" title="3.1 并行计算"></a>3.1 并行计算</h3><p>​		在介绍Flink的DAG内部转化之前，首先需要介绍一个基本概念——并行度Parallelism。</p>
<p>​		上面已经说了，Flink任务可以看做成source—transformation—sink这样一个个算子相连的数据处理过程。对于单独一个数据而言，这个数据处理过程显然是没法并行的。对于单个数据而言，不可能说source和sink并行，因为只有经历了source和transformation才可以执行sink算子。所以说<strong>并行只针对多条数据而言</strong>！</p>
<p>​		那我们这里说的并行是什么呢？</p>
<p>​		<strong>其实Flink中的并行指的是“数据并行”——多条数据同时到来，我们应该可以同时source读入，同时在不同节点执行 flatMap 等transformation操作。</strong></p>
<p>​		怎样实现数据并行呢？其实也很简单，<strong>我们把一个算子操作，“复制”多份到多个节点，数据来了之后就可以到其中任意一个执行。</strong>这样一来，<strong>一个算子任务就被拆分成了多个并行的“子任务”（subtasks），再将它们分发到不同节点，就真正实现了并行计算。</strong>在 Flink 执行过程中，<strong>每一个算子（operator）可以包含一个或多个子任务（operator subtask），这些子任务在不同的线程、不同的物理机或不同的容器中完全独立地执行。</strong></p>
<p>​		<strong>我们通过拆分算子的形式实现数据并行</strong>：</p>
<p><img src="/2024/01/15/flink-frame/image-20231217012240834.png" alt="image-20231217012240834"></p>
<h3 id="3-2-算子链"><a href="#3-2-算子链" class="headerlink" title="3.2 算子链"></a>3.2 算子链</h3><p>​		数据流在算子之间传输数据的形式可以是一对一（one-to-one）的直通 (forwarding)模式，也可以是打乱的重分区（redistributing）&#x2F;shuffle模式，具体是哪一种形式，取决于算子的种类。</p>
<p>​		如上图source-map之间为forwarding模式，但是map-…-sink是redistributing模式。</p>
<p>​		在 Flink 中，并行度相同的一对一（one to one）算子操作，可以直接链接在一起形成一个“大”的任务（task），这样原来的算子就成为了真正任务里的一部分，<strong>如上图所示，source1和map1会作为一个task，最终会被一个线程执行</strong>。这样的技术被称为“算子链”（Operator Chain）。</p>
<p>​		Flink 为什么要有算子链这样一个设计呢？这是因为将算子链接成 task 是非常有效的优化：<strong>可以减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量。</strong></p>
<h3 id="3-3-Logic-StreamGraph→-Physical-Graph"><a href="#3-3-Logic-StreamGraph→-Physical-Graph" class="headerlink" title="3.3 Logic StreamGraph→ Physical Graph"></a>3.3 Logic StreamGraph→ Physical Graph</h3><p>​		<strong>由 Flink 程序直接映射成的数据流图（dataflow graph），也被称为逻辑流图（logical StreamGraph）</strong>，因为它们表示的是计算逻辑的高级视图。</p>
<p>​		到具体执行环节时，我们还要考虑并行子任务的分配、数据在任务间的传输，以及合并算子链的优化。为了说明最终应该怎样执行一个流处理程序，<strong>Flink 需要将逻辑流图进行解析，转换为物理数据流图。</strong></p>
<p><strong>逻辑流图（StreamGraph）→ 作业图（JobGraph）→ 执行图（ExecutionGraph）→ 物理图（Physical Graph）</strong></p>
<p><img src="/2024/01/15/flink-frame/image-20231217013739113.png" alt="image-20231217013739113"></p>
<ol>
<li>逻辑流图（StreamGraph）   生成DAG</li>
</ol>
<p>​		这是根据用户通过 DataStream API 编写的代码生成的最初的 DAG 图，用来表示程序的拓扑结构。<strong>这一步一般在客户端完成。</strong></p>
<p>我们可以看到，逻辑流图中的节点，完全对应着代码中的四步算子操作：源算子 Source（socketTextStream()）→扁平映射算子 Flat Map(flatMap()) →分组聚合算子Keyed Aggregation(keyBy&#x2F;sum()) →输出算子 Sink(print())。</p>
<ol start="2">
<li>作业图（JobGraph）   实现算子链优化</li>
</ol>
<p>​		StreamGraph 经过优化后生成的就是作业图（JobGraph），<strong>这是提交给 JobManager 的数据结构，确定了当前作业中所有任务的划分。</strong>主要的优化为: 将多个符合条件的节点链接在一起合并成一个任务节点，<strong>形成算子链</strong>，这样可以减少数据交换的消耗。<strong>JobGraph 一般也是在客户端生成的，在作业提交时传递给 JobMaster。</strong></p>
<ol start="3">
<li>执行图（ExecutionGraph）   实现并行度</li>
</ol>
<p>​		<strong>JobMaster 收到 JobGraph 后，会根据它来生成执行图（ExecutionGraph）</strong>。ExecutionGraph是 JobGraph 的<strong>并行化</strong>版本，是调度层最核心的数据结构。</p>
<p>​		<strong>与 JobGraph 最大的区别就是按照并行度对并行子任务进行了拆分，并明确了任务间数据传输的方式。</strong>待。。。。</p>
<ol start="4">
<li>物理图（Physical Graph）</li>
</ol>
<p>​		<strong>JobMaster 生成执行图后， 会将它分发给 TaskManager；各个 TaskManager 会根据执行图部署任务，最终的物理执行过程也会形成一张“图”，一般就叫作物理图（Physical Graph）</strong>。这只是具体执行层面的图，并不是一个具体的数据结构。物理图主要就是在执行图的基础上，进一步确定数据存放的位置和收发的具体方式。有了物理图，TaskManager 就可以对传递来的数据进行处理计算了。</p>
<p>​		所以我们可以看到，程序里定义了四个算子操作：源（Source）-&gt;转换（flatMap）-&gt;分组聚合（keyBy&#x2F;sum）-&gt;输出（print）；合并算子链进行优化之后，就只有三个任务节点了；再考虑并行度后，一共有 5 个并行子任务，最终需要 5 个线程来执行。</p>
<h2 id="四、任务槽（task-slot）"><a href="#四、任务槽（task-slot）" class="headerlink" title="四、任务槽（task slot）"></a>四、任务槽（task slot）</h2><p>​		上面主要介绍了Flink任务提交流程和数据流图的变化，我们可以了解到Flink在着期间做了并行计算，比如上面的wordcount，最后对应了5个subtask、5个线程来并行处理数据。</p>
<p>​		但是对于TaskManager，我们上面介绍了是一个工作进程，那么TM进程和上面说的并行计算的线程怎么对应呢？<strong>一个TM有几个线程？一个wordcount对应一个JM，那么对应几个TM呢？实际上这其中的关系是由slot进行联系的。</strong></p>
<p>​		之前已经提到过，Flink 中每一个 worker(也就是 TaskManager)都是一个 JVM 进程，它可以启动多个独立的线程，来并行执行多个子任务（subtask）。所以<strong>如果想要执行 5 个任务，并不一定非要 5 个 TaskManager，我们可以让 TaskManager多线程执行任务。</strong>如果可以同时运行 5 个线程，那么只要一个 TaskManager 就可以满足我们之前程序的运行需求了。</p>
<p>​		<strong>但是TaskManager 的计算资源是有限的，并不是所有任务都可以放在一个 TaskManager上并行执行。并行的任务越多，每个线程的资源就会越少。</strong></p>
<p>​		<strong>那一个 TaskManager 到底能并行处理多少个任务呢？</strong></p>
<p>​		为了<strong>控制并发量</strong>，我们需要在 TaskManager 上对每个任务运行所占用的资源做出明确的划分，这就是所谓的任务槽（task slots）。</p>
<p><img src="/2024/01/15/flink-frame/image-20231217022548524.png" alt="image-20231217022548524"></p>
<p>​		假如一个 TaskManager 有三个 slot，<strong>那么它会将管理的内存平均分成三份</strong>，每个 slot 独自占据一份。这样一来，我们在 slot 上执行<strong>一个子任务时，相当于划定了一块内存“专款专用”，就不需要跟来自其他作业的任务去竞争内存资源了</strong>。所以现在我们只要 2 个 TaskManager，就可以并行处理分配好的 5 个任务了。</p>
<p>​		<strong>TM设置多个slot，意味着多个子任务可以共享一个JVM。意味着在同一个 JVM 进程中运行的任务，将共享 TCP 连接和心跳消息，也可能共享数据集和数据结构，这就减少了每个任务的运行开销，在降低隔离级别的同时提升了性能。</strong></p>
<p>​		slot 目前仅仅用来隔离内存，不会涉及 CPU 的隔离。在具体应用时，可以将 slot 数量配置为机器的 CPU 核心数，尽量避免不同任务之间对 CPU 的竞争。这也是开发环境默认并行度设为机器 CPU 数量的原因。</p>
<p>​		但是上面我们介绍的都是slot充足的理想状况，如果当前只有2个TM，各包含3个slot，那么对于分为13个subtask的任务应该怎么办呢？</p>
<p><img src="/2024/01/15/flink-frame/image-20231217023352283.png" alt="image-20231217023352283"></p>
<p>如上图所示，我们可以让多个子任务共享slot。</p>
<p>​		当我们<strong>将资源密集型和非密集型的任务同时放到一个 slot 中，它们就可以自行分配对资源占用的比例，</strong>从而保证最重的活平均分配给所有的TaskManager。  待。。。。。。。。。。。。</p>
<p>flink中一个slot中被source1和keyby1两个子任务共享，请问它们的共享是可以同时运行吗？还是说空间上共享，时间上是串行的？待。。。。。。。。</p>
<p>​		<strong>slot 共享另一个好处就是允许我们保存完整的作业管道。</strong>这样一来，即使某个 TaskManager出现故障宕机，其他节点也可以完全不受影响，作业的任务可以继续执行。</p>
<p>​		另外，<strong>同一个任务节点的并行子任务是不能共享 slot 的</strong>，所以允许 slot 共享之后，运行作业所需的 slot 数量正好就是作业中所有算子并行度的最大值。这样一来，我们考虑当前集群需要配置多少 slot 资源时，就不需要再去详细计算一个作业总共包含多少个并行子任务了，只看最大的并行度就够了。</p>
<blockquote>
<p>这里肯定不能让“数据并行”（即是并行子任务）的任务放到一个slot，否则就不叫并行了</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/shenfentyin">Shen Fengyin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://shenfenyin.github.io/2024/01/15/flink-frame/">http://shenfenyin.github.io/2024/01/15/flink-frame/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://shenfenyin.github.io" target="_blank">SHENFY BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Flink/">Flink</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/">分布式架构</a></div><div class="post_share"><div class="social-share" data-image="/img/sfy_portriat.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/15/git-command/" title="Git命令介绍"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Git命令介绍</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/15/Embedding-word2vec/" title="Embedding简单介绍"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Embedding简单介绍</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/15/sql-join/" title="SQL JOIN算子"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-15</div><div class="title">SQL JOIN算子</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/sfy_portriat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Shen Fengyin</div><div class="author-info__description">记录博主日常学习记录，包括后端、大数据相关开发知识，后续会陆续更新机器学习的部分~~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/shenfengyin"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/shenfengyin" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:shenfy@stu.pku.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">博客内容更新-ing</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Flink%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">Flink运行时架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-Flink%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">一、 Flink系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%88JobManager%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 作业管理器（JobManager）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%88TaskManager%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 任务管理器（TaskManager）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-Flink%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">二、 Flink作业提交流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%8A%BD%E8%B1%A1%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 抽象作业提交流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-yarn%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 yarn集群部署模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81-FLink%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE"><span class="toc-number">1.3.</span> <span class="toc-text">三、 FLink数据流图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 并行计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%AE%97%E5%AD%90%E9%93%BE"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 算子链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Logic-StreamGraph%E2%86%92-Physical-Graph"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 Logic StreamGraph→ Physical Graph</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BB%BB%E5%8A%A1%E6%A7%BD%EF%BC%88task-slot%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">四、任务槽（task slot）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/new-UUID/" title="新版雪花算法的理解">新版雪花算法的理解</a><time datetime="2024-01-14T16:51:57.855Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/LSM/" title="LSM学习">LSM学习</a><time datetime="2024-01-14T16:51:57.852Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/hexo-butterfly/" title="使用hexo搭建离线博客">使用hexo搭建离线博客</a><time datetime="2024-01-14T16:51:57.848Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/git-command/" title="Git命令介绍">Git命令介绍</a><time datetime="2024-01-14T16:51:57.846Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/flink-frame/" title="Flink运行时架构">Flink运行时架构</a><time datetime="2024-01-14T16:51:57.843Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Shen Fengyin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">身体健康，吃好喝好~.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>