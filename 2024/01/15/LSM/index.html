<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>LSM学习 | SHENFY BLOG</title><meta name="author" content="Shen Fengyin"><meta name="copyright" content="Shen Fengyin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[转载]LSM树讲清楚了LSM merge的基本原理：http:&#x2F;&#x2F;weakyon.com&#x2F;2015&#x2F;04&#x2F;08&#x2F;Log-Structured-Merge-Trees.html#%E4%B8%80%E4%BA%9B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86 讲清楚了LSM的两种compact方法（磁盘)：1 size-tiered （merge）2 leveled (">
<meta property="og:type" content="article">
<meta property="og:title" content="LSM学习">
<meta property="og:url" content="http://shenfenyin.github.io/2024/01/15/LSM/index.html">
<meta property="og:site_name" content="SHENFY BLOG">
<meta property="og:description" content="[转载]LSM树讲清楚了LSM merge的基本原理：http:&#x2F;&#x2F;weakyon.com&#x2F;2015&#x2F;04&#x2F;08&#x2F;Log-Structured-Merge-Trees.html#%E4%B8%80%E4%BA%9B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86 讲清楚了LSM的两种compact方法（磁盘)：1 size-tiered （merge）2 leveled (">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://shenfenyin.github.io/img/sfy_portriat.jpg">
<meta property="article:published_time" content="2024-01-14T16:51:57.852Z">
<meta property="article:modified_time" content="2024-01-14T17:55:01.854Z">
<meta property="article:author" content="Shen Fengyin">
<meta property="article:tag" content="LSM">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://shenfenyin.github.io/img/sfy_portriat.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://shenfenyin.github.io/2024/01/15/LSM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LSM学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-15 01:55:01'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/sfy_portriat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 近期博客</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 相关</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="SHENFY BLOG"><span class="site-name">SHENFY BLOG</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 近期博客</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 相关</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">LSM学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-14T16:51:57.852Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-14T17:55:01.854Z" title="更新于 2024-01-15 01:55:01">2024-01-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LSM学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="转载-LSM树"><a href="#转载-LSM树" class="headerlink" title="[转载]LSM树"></a>[转载]LSM树</h1><p>讲清楚了LSM merge的基本原理：<a target="_blank" rel="noopener" href="http://weakyon.com/2015/04/08/Log-Structured-Merge-Trees.html#%E4%B8%80%E4%BA%9B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86">http://weakyon.com/2015/04/08/Log-Structured-Merge-Trees.html#%E4%B8%80%E4%BA%9B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86</a></p>
<p>讲清楚了LSM的两种compact方法（磁盘)：1 size-tiered （merge）2 leveled (有点像跳表？？？)<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/181498475">https://zhuanlan.zhihu.com/p/181498475</a></p>
<p>LSM树，即日志结构合并树(Log-Structured Merge-Tree)。 其实它并不属于一个具体的数据结构，它更多是一种数据结构的设计思想。 大多NoSQL数据库核心思想都是基于LSM来做的， 只是具体的实现不同。</p>
<blockquote>
<p>B+树和LSM存储结构，二者写性能差异主要有两点（？存疑</p>
<p>1、异步持久化磁盘！1.1内存不是无限的 1.2redo log也不是无限大。每当写到一定量的时候就需要触发一次同步刷盘，同时会阻塞写操作。对于写来说性能瓶颈就在刷盘这个地方。<strong>lsm由于顺序刷盘这个瓶颈比mysql高。</strong></p>
<p>2、mysql是直接改原数据，需要将磁盘上的数据读出来，再写进去，而lsm直接写就ok了。</p>
</blockquote>
<p>LSM经常和B+树进行对比来看。<strong>在用法上，我们常见的Innodb引擎采用的是原地更新（B+tree），而其他NoSql类型的数据库大多采用追加式更新（LSMtree）</strong></p>
<p><img src="/LSM.assets/lsmtree-1.png" alt="img"></p>
<center>图1：LSM存储结构</center>		

<p>​		它的核心思路其实非常简单**，就是假定内存足够大，因此不需要每次有数据更新就必须将数据写入到磁盘中， 而可以先将最新的数据驻留在内存中，等到积累到最后多之后，再使用归并排序的方式将内存内的数据合并追加到磁盘队尾 (因为所有待排序的树都是有序的，可以通过合并排序的方式快速合并到一起)**。</p>
<p>​		<strong>核心特点是利用顺序写来提高写性能，但因为分层(此处分层是指的分为内存和文件两部分)的设计会稍微降低读性能，但是通过牺牲小部分读性能换来高性能写，使得LSM树成为非常流行的存储结构。</strong></p>
<p>LSM具有批量特性，存储延迟。当写读比例很大的时候（写比读多），LSM树相比于B树有更好的性能。因为随着insert操作，为了维护B树结构，节点分裂。 读磁盘的随机读写概率会变大，性能会逐渐减弱。 多次单页随机写，变成一次多页随机写,复用了磁盘寻道时间，极大提升效率。</p>
<p>LSM Tree弄了很多个小的有序结构，比如每m个数据，在内存里排序一次，下面m个数据，再排序一次……这样依次做下去，我就可以获得N&#x2F;m个有序的小的有序结构。</p>
<p>在查询的时候，因为不知道这个数据到底是在哪里，所以就从最新的一个小的有序结构里做二分查找，找得到就返回，找不到就继续找下一个小有序结构，一直到找到为止。 很容易可以看出，这样的模式，读取的时间复杂度是(N&#x2F;m)*log2N 。读取效率是会下降的。</p>
<p>当然也可以做一些优化</p>
<ul>
<li>Bloom filter: 就是个带随即概率的bitmap,可以快速的告诉你，某一个小的有序结构里有没有指定的那个数据的。于是就可以不用二分查找，而只需简单的计算几次就能知道数据是否在某个小集合里啦。效率得到了提升，但付出的是空间代价。</li>
<li>compact:小树合并为大树:因为小树他性能有问题，所以要有个进程不断地将小树合并到大树上，这样大部分的老数据查询也可以直接使用log2N的方式找到，不需要再进行(N&#x2F;m)*log2n的查询了</li>
</ul>
<h3 id="LSM树诞生背景"><a href="#LSM树诞生背景" class="headerlink" title="LSM树诞生背景"></a>LSM树诞生背景</h3><p>传统关系型数据库使用btree或一些变体作为存储结构，能高效进行查找。 但保存在磁盘中时它也有一个明显的缺陷，那就是逻辑上相离很近但物理却可能相隔很远，这就可能造成大量的磁盘随机读写。 随机读写比顺序读写慢很多，<strong>为了提升IO性能，我们需要一种能将随机操作变为顺序操作的机制</strong>，于是便有了LSM树。 LSM树能让我们进行顺序写磁盘，从而大幅提升写操作，作为代价的是牺牲了一些读性能。</p>
<h3 id="关于磁盘IO"><a href="#关于磁盘IO" class="headerlink" title="关于磁盘IO"></a>关于磁盘IO</h3><p>磁盘读写时涉及到磁盘上数据查找，地址一般由柱面号、盘面号和块号三者构成。也就是说移动臂先根据柱面号移动到指定柱面，然后根据盘面号确定盘面的磁道，最后根据块号将指定的磁道段移动到磁头下，便可开始读写。</p>
<p>整个过程主要有三部分时间消耗，查找时间(seek time) +等待时间(latency time)+传输时间(transmission time) 。分别表示定位柱面的耗时、将块号指定磁道段移到磁头的耗时、将数据传到内存的耗时。 整个磁盘IO最耗时的地方在查找时间，所以减少查找时间能大幅提升性能。</p>
<h3 id="LSM树原理"><a href="#LSM树原理" class="headerlink" title="LSM树原理"></a>LSM树原理</h3><p>LSM树由两个或以上的存储结构组成，比如在论文中为了方便说明使用了最简单的两个存储结构。比如<strong>内存+磁盘</strong>：一个存储结构常驻内存中，称为C0 tree，具体可以是任何方便健值查找的数据结构，比如红黑树、map之类，甚至可以是跳表。 另外一个存储结构常驻在硬盘中，称为C1 tree，具体结构类似B树。C1所有节点都是100%满的，节点的大小为磁盘块大小。</p>
<p><img src="/LSM.assets/lsmtree-2.png" alt="img"></p>
<h3 id="插入步骤"><a href="#插入步骤" class="headerlink" title="插入步骤"></a>插入步骤</h3><p>大体思路是：插入一条新纪录时，首先在日志文件中插入操作日志，以便后面恢复使用，日志是以append形式插入，所以速度非常快；将新纪录的索引插入到C0中，这里在内存中完成，不涉及磁盘IO操作；<strong>当C0大小达到某一阈值时或者每隔一段时间，将C0中记录滚动合并到磁盘C1中；</strong>对于<strong>多个存储结构的情况，当C1体量越来越大就向C2合并，以此类推，一直往上合并Ck（为了优化读性能）</strong>。</p>
<p><img src="/LSM.assets/lsmtree-3.png" alt="img"></p>
<h3 id="合并步骤"><a href="#合并步骤" class="headerlink" title="合并步骤"></a>合并步骤</h3><p>合并过程中会使用两个块：emptying block和filling block。</p>
<p>从C1中读取未合并叶子节点，放置内存中的emptying block中。从小到大找C0中的节点，与emptying block进行合并排序，合并结果保存到filling block中，并将C0对应的节点删除。不断执行第2步操作，合并排序结果不断填入filling block中，<strong>当其满了则将其追加到磁盘的新位置上，注意是追加而不是改变原来的节点。</strong>合并期间如故宫emptying block使用完了则再从C1中读取未合并的叶子节点。C0和C1所有叶子节点都按以上合并完成后即完成一次合并。</p>
<h3 id="关于优化措施"><a href="#关于优化措施" class="headerlink" title="关于优化措施"></a>关于优化措施</h3><p>本文用图阐述LSM的基本原理，但实际项目中其实有很多优化策略，而且有很多针对LSM树优化的paper。比如使用布隆过滤器快速判断key是否存在，还有做一些额外的索引以帮助更快找到记录等等。</p>
<h3 id="插入操作-实例演示"><a href="#插入操作-实例演示" class="headerlink" title="插入操作-实例演示"></a>插入操作-实例演示</h3><p>向LSM树中插入</p>
<p>A E L R U</p>
<p>首先会插入到内存中的C0树上，这里使用AVL树，插入“A”，先向磁盘日志文件追加记录，然后再插入C0</p>
<p><img src="/LSM.assets/lsmtree-4.png" alt="img"></p>
<p>插入“E”，同样先追加日志再写内存，</p>
<p><img src="/LSM.assets/lsmtree-5.png" alt="img"></p>
<p>继续插入“L”，旋转后如下，</p>
<p><img src="/LSM.assets/lsmtree-6.png" alt="img"></p>
<p>插入“R”“U”，旋转后最终如下。</p>
<p><img src="/LSM.assets/lsmtree-7.png" alt="img"></p>
<p>假设此时触发合并，则因为C1还没有树，所以emptying block为空，直接从C0树中依次找最小的节点。filling block长度为4，这里假设磁盘块大小为4。</p>
<p>开始找最小的节点，并放到filling block中，</p>
<p><img src="/LSM.assets/lsmtree-8.png" alt="img"></p>
<p>继续找第二个节点，</p>
<p><img src="/LSM.assets/lsmtree-9.png" alt="img"></p>
<p>以此类推，填满filling block</p>
<p><img src="/LSM.assets/lsmtree-10.png" alt="img"></p>
<p>开始写入磁盘，C1树，</p>
<p><img src="https://fhfirehuo.github.io/Attacking-Java-Rookie/image/c2/lsmtree-11.png" alt="img"></p>
<p>继续插入</p>
<p>B F N T</p>
<p>先分别写日志，然后插入到内存的C0树中</p>
<p><img src="/LSM.assets/lsmtree-12.png" alt="img"></p>
<p>假如此时进行合并，先加载C1的最左边叶子节点到emptying block，</p>
<p><img src="/LSM.assets/lsmtree-13.png" alt="img"></p>
<p>接着对C0树的节点和emptying block进行合并排序，首先是“A”进入filling block，</p>
<p><img src="/LSM.assets/lsmtree-14.png" alt="img"></p>
<p>然后是“B”，</p>
<p><img src="/LSM.assets/lsmtree-15.png" alt="img"></p>
<p>合并排序最终结果为，</p>
<p><img src="/LSM.assets/lsmtree-16.png" alt="img"></p>
<p>将filling block追加到磁盘的新位置，将原来的节点删除掉（<strong>覆盖或者用版本号</strong>，</p>
<p><img src="/LSM.assets/lsmtree-17.png" alt="img"></p>
<p>继续合并排序，再次填满filling block，</p>
<p><img src="/LSM.assets/lsmtree-18.png" alt="img"></p>
<p>将filling block追加到磁盘的新位置，上一层的节点也要以磁盘块（或多个磁盘块）大小写入，尽量避开随机写。另外由于合并过程可能会导致上层节点的更新，可以暂时保存在内存，后面在适当时机写入。</p>
<p><img src="/LSM.assets/lsmtree-19.png" alt="img"></p>
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p><strong>查找总体思想是先找内存的C0树，找不到则找磁盘的C1树，然后是C2树，以此类推。</strong></p>
<p>假如要找“B”，先找C0树，没找到。</p>
<p><img src="/LSM.assets/lsmtree-20.png" alt="img"></p>
<p>接着找C1树，从根节点开始，</p>
<p><img src="/LSM.assets/lsmtree-21.png" alt="img"></p>
<p>找到“B”。</p>
<p><img src="/LSM.assets/lsmtree-22.png" alt="img"></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除操作为了能快速执行，主要是通过标记来实现，在内存中将要删除的记录标记一下，后面异步执行合并时将相应记录删除。</p>
<p>比如要删除“U”，假设标为#的表示删除，则C0树的“U”节点变为，</p>
<p><img src="/LSM.assets/lsmtree-23.png" alt="img"></p>
<p>而<strong>如果C0树不存在的记录，则在C0树中生成一个节点，并标为#，查找时就能在内存中得知该记录已被删除，无需去磁盘找了</strong>。比如要删除“B”，那么没有必要去磁盘执行删除操作，直接在C0树中插入一个“B”节点，并标为#。</p>
<p><img src="/LSM.assets/lsmtree-24.png" alt="img"></p>
<p>​		</p>
<h2 id="二次介绍"><a href="#二次介绍" class="headerlink" title="二次介绍"></a>二次介绍</h2><p>假如对写操作的吞吐量比较敏感，可采用日志策略（顺序读写，只追加不修改）来提升写性能。存在问题：数据查找需要倒序扫描，花费很多时间。比如，预写日志WAL，WAL的中心概念是数据文件（存储着表和索引）的修改必须在这些动作被日志记录之后才被写入，即在描述这些改变的日志记录被刷到持久存储以后。如果我们遵循这种过程，我们不需要在每个事务提交时刷写数据页面到磁盘，因为我们知道在发生崩溃时可以使用日志来恢复数据库：任何还没有被应用到数据页面的改变可以根据其日志记录重做（这是前滚恢复，也被称为REDO）。使用WAL可以显著降低磁盘的写次数，因为只有日志文件需要被刷出到磁盘以保证事务被提交，而被事务改变的每一个数据文件则不必被刷出。</p>
<p>其只是提高了写的性能，对于更为复杂的读性能，需要寻找其他的方法，其中有四种方法来提升读性能：</p>
<ul>
<li>二分查找: 将文件数据有序保存，使用二分查找来完成特定key的查找。</li>
<li>哈希：用哈希将数据分割为不同的bucket</li>
<li>B+树：使用B+树 或者 ISAM 等方法，可以减少外部文件的读取</li>
<li>外部文件： 将数据保存为日志，并创建一个hash或者查找树映射相应的文件。</li>
</ul>
<p>所有的四种方法都可以有效的提高了读操作的性能（最少提供了O(log(n)) )，但是，却丢失了日志文件超好的写性能，上面这些方法，都强加了总体的结构信息在数据上，数据被按照特定的方式放置，所以可以很快的找到特定的数据，但是却对写操作不友善，让写操作性能下降。更糟糕的是，当需要更新hash或者B+树的结构时，需要同时更新文件系统中特定的部分，这就是造成了比较慢的随机读写操作，这种随机的操作要尽量减少。</p>
<p><strong>既要保证日志文件好的写性能，又要在一定程度上保证读性能，所以LSM-Tree应运而生。</strong></p>
<p>讲LSM树之前，需要提下三种基本的存储引擎，这样才能清楚LSM树的由来：</p>
<ul>
<li><strong>哈希存储引擎</strong> 是哈希表的持久化实现，支持增、删、改以及随机读取操作，但不支持顺序扫描，对应的存储系统为key-value存储系统。<strong>对于key-value的插入以及查询，哈希表的复杂度都是O(1)，明显比树的操作O(n)快</strong>,如果不需要有序的遍历数据，哈希表就是your Mr.Right，但是实际上合适的hash函数很难找，我们需要处理冲突。</li>
<li><strong>B树存储引擎</strong>是B树（关于B树的由来，数据结构以及应用场景可以看之前一篇博文）的持久化实现，不仅支持单条记录的增、删、读、改操作，还<strong>支持顺序扫描（B+树的叶子节点之间的指针）</strong>，对应的存储系统就是关系数据库（Mysql等）。</li>
<li>LSM树（Log-Structured Merge Tree）存储引擎和B树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且<strong>通过批量存储技术规避磁盘随机写入问题</strong>。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。</li>
</ul>
<p>LSM树（Log Structured Merge Tree，结构化合并树）的思想非常朴素，就是将对数据的<strong>修改增量保持在内存</strong>中，达到指定的大小限制后将这些修改操作批量写入磁盘（由此提升了写性能），是一种基于硬盘的数据结构，与B-tree相比，能显著地减少硬盘磁盘臂的开销。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。</p>
<p>读取时需要合并磁盘中的历史数据和内存中最近的修改操作,<strong>读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件（存储在磁盘中的是许多小批量数据，由此降低了部分读性能。</strong>但是<strong>磁盘中会定期做merge操作，合并成一棵大树，以优化读性能</strong>）。LSM树的优势在于有效地规避了磁盘随机写入问题，但读取时可能需要访问较多的磁盘文件。</p>
<p>代表数据库：nessDB、leveldb、hbase等</p>
<p>核心思想的核心就是放弃部分读能力，换取写入的最大化能力，放弃磁盘读性能来换取写的顺序性。极端的说，基于LSM树实现的HBase的写性能比Mysql高了一个数量级，读性能低了一个数量级。</p>
<h3 id="LSM操作"><a href="#LSM操作" class="headerlink" title="LSM操作"></a>LSM操作</h3><p>LSM树 插入数据可以看作是一个N阶合并树。数据写操作（包括插入、修改、删除也是写）都在内存中进行，</p>
<p>数据首先会插入内存中的树。<strong>当内存树的数据量超过设定阈值后，会进行合并操作</strong>。合并操作会从左至右遍历<strong>内存中树的子节点</strong> 与 <strong>磁盘中树的子节点</strong>并进行合并，会用<strong>最新更新的数据覆盖旧的数据（或者记录为不同版本）</strong>。<strong>当被合并合并数据量达到磁盘的存储页大小时。会将合并后的数据持久化到磁盘，同时更新父节点对子节点的指针。</strong></p>
<p>LSM树 读数据 磁盘中书的非子节点数据也被缓存到内存中。在需要进行读操作时，总是从内存中的排序树开始搜索，如果没有找到，就从磁盘上的排序树顺序查找。</p>
<p>在LSM树上进行一次数据更新不需要磁盘访问，在内存即可完成，速度远快于B+树。当数据访问以写操作为主，而读操作则集中在最近写入的数据上时，使用LSM树可以极大程度地减少磁盘的访问次数，加快访问速度。</p>
<p>LSM树 删除数据 前面讲了。LSM树所有操作都是在内存中进行的，那么删除并不是物理删除<strong>。而是一个逻辑删除，会在被删除的数据上打上一个标签，当内存中的数据达到阈值的时候，会与内存中的其他数据一起顺序写入磁盘。</strong> 这种操作会占用一定空间，但是LSM-Tree 提供了一些机制回收这些空间。</p>
<h3 id="LSM-VS-B树"><a href="#LSM-VS-B树" class="headerlink" title="LSM VS B树"></a>LSM VS B树</h3><p>B树被广泛应用于各种传统数据库。采用了<strong>B树的存储系统，所有数据都是排序的，并将这些数据分成一个个page。而B树就是指向这些page的索引组成的m阶树</strong>。每次读写数据的过程就是顺着B树查找或更新各个page的过程。B树相对于AVL、红黑树等的优点在于可以减少文件读写次数。 </p>
<p>对比LSM和B树之前，我们先来考虑一下它们为什么会设计成这样？</p>
<p>要设计一个系统，我们可以从最简单的设计出发。对于存储系统，最简单的就是把记录直接写到记录文件的末尾，这样的做法写效率是最高的。然而要查询某一条记录，需要遍历整个文件，这是无法接受的。</p>
<p>为了快速查询，一个办法是建立hash索引，但是hash索引有其自己的问题，比如数据量大的时候，索引在内存中就放不下了。另一个办法就是事先对数据进行排序。从排好序的文件中查找记录有一箱的数据结构可以用，平衡二叉树、堆、红黑树等等，还有今天的主角B树（啊，不，B树只是被来出来陪衬的，今天的主角是LSM）。 </p>
<p>这里的关键是“事先”是什么时候。首先会想到的思路是在写入的时候。在计算机系统中真正foundmental的创新是很不容易的。大多数的优化其实都是tradeoff，也就是牺牲一点A，得到一点B。在这里，一共两种操作，写入或者读取，为了提高读取效率，我们就要在写入的时候多做一些事情。对于B树，这多做的事情首先是找到正确的位置，其次还会有page的分裂等。 大多数时候，B树的表现是很优秀的，他也一直很努力的提高自己，不断增加新技能，进化出了B+\B*树等进化体。然而当系统同时服务的客户越来越来多，对吞吐量的要求越来越高。</p>
<p>B树表示在大并发写操作的时候，压力有点大，因为要做的事情有点多。那怎么办，为了读取数据的时候轻松一点，这些事情不得不做啊。 当B树不堪重负的时候，主角LSM树登场了。</p>
<p>他说，想要有高的写吞吐，就给我减负，我可管不了那么多，我可是主角。作者也很无奈，想想也是，哪个主角没几个挂呢，给他开挂吧。本来都是写入的时候要做的事，就少做一点吧，给你几个后台线程，剩下的事情用它们做吧。有了这几个后台线程帮忙，LSM树处理大量写入的能力一下就上来了。LSM由此直接拿下Hbase、Cassandra、kudu等大量地盘。老大哥B树表示，他有挂，我很慌。 到这里就比较清楚了，B树把所有的压力都放到了写操作的时候，从根节点索引到数据存储的位置，可能需要多次读文件；真正插入的时候，又可能会引起page的分裂，多次写文件。</p>
<p><strong>而LSM树在插入的时候，直接写入内存，只要利用红黑树保持内存中的数据有序即可，所以可以提供更高的写吞吐。</strong>不过，把compaction交给后台线程来做，意味着有时间差，读取的时候，通常不止一个SSTable，要么逐个扫描，要么先merge，所以会影响到读效率。另外，当后台线程做compaction的时候，占用了IO带宽，这时也会影响到写吞吐。所以B树还不会被LSM取代。</p>
<h3 id="Hbase-VS-kudu-待。。。"><a href="#Hbase-VS-kudu-待。。。" class="headerlink" title="Hbase VS kudu  待。。。"></a>Hbase VS kudu  待。。。</h3><p>Hbase 的存储实现是LSM的典型应用，适合大规模在线读写。然而，除了这种OLTP的访问模式，正如我在大数据场景与挑战中提到的，还有一种OLAP的数据访问模式，Hbase其实是不合适的。对此，最常见的做法是定期把数据导出到专门针对OLAP场景的存储系统。这个做法一点都不优雅，因为一份同样的数据同时存在两个不同的地方，而且还会有一个不一致的时间窗口。Kudu就是为了解决这个问题而诞生的。我最早看到kudu就很有兴趣，也很好奇，一个存储系统能同时满足OLTP和OLAP两种场景，那是厉害的。不过现在kudu由于运维成本等其他问题还没有被广泛采用，挺可惜的。 扯远了，我们来看为了更好的支持OLAP，kudu对LSM做了哪些优化。</p>
<p>OLAP经常会做列选择，所有的OLAP存储引擎都是以列式存储的。kudu也想到了这一点。kudu的memtable(在kudu中叫MemRowSet)还是同之前一样，只是SSTable(在kudu中叫DiskRowSet)改成了列式存储。对于列式存储，读取一个记录需要分别读每个字段，因此kudu精心设计了RowSet中的索引(针对并发访问等改进过的B树)，加速这个过程。 除了列式存储，kudu保证一个key只可能出现在一个RowSet中，并记录了每个RowSet中key的最大值和最小值，加速数据的范围查找。这也意味着，对于数据更新，不能再像之前一样直接插入memtable即可。需要找到对应的RowSet去更新，为了保持写吞吐，kudu并不直接更新RowSet，而是又新建一个DeltaStore，专门记录数据的更新。所以，后台除了RowSet的compaction线程，还要对DeltaStore进行merge和apply。从权衡的角度考虑，kudu其实是牺牲了一点写效率，单记录查询效率，换取了批量查询效率。</p>
<h3 id="这样看来，从B树到LSM，到kudu对LSM的优化，其实都是针对不同场景不同的访问需求做出的各种权衡而已。了解了这些，我们在选择这些技术的时候心里就有底了。另外，权衡并不是那么容易的事。怎么样牺牲A去补偿B，可能有不同的策略。研究现有系统的一些思想，有助于当我们自己面临问题的时候，有更多思路。"><a href="#这样看来，从B树到LSM，到kudu对LSM的优化，其实都是针对不同场景不同的访问需求做出的各种权衡而已。了解了这些，我们在选择这些技术的时候心里就有底了。另外，权衡并不是那么容易的事。怎么样牺牲A去补偿B，可能有不同的策略。研究现有系统的一些思想，有助于当我们自己面临问题的时候，有更多思路。" class="headerlink" title="这样看来，从B树到LSM，到kudu对LSM的优化，其实都是针对不同场景不同的访问需求做出的各种权衡而已。了解了这些，我们在选择这些技术的时候心里就有底了。另外，权衡并不是那么容易的事。怎么样牺牲A去补偿B，可能有不同的策略。研究现有系统的一些思想，有助于当我们自己面临问题的时候，有更多思路。"></a>这样看来，从B树到LSM，到kudu对LSM的优化，其实都是针对不同场景不同的访问需求做出的各种权衡而已。了解了这些，我们在选择这些技术的时候心里就有底了。另外，权衡并不是那么容易的事。怎么样牺牲A去补偿B，可能有不同的策略。研究现有系统的一些思想，有助于当我们自己面临问题的时候，有更多思路。</h3><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>LSM树（Log-Structured Merge Tree）存储引擎</strong></p>
<p><strong>代表数据库：nessDB、leveldb、hbase等</strong></p>
<p>核心思想的核心就是放弃部分读能力，换取写入的最大化能力。LSM Tree ，这个概念就是结构化合并树的意思，它的核心思路其实非常简单，就是假定内存足够大，因此不需要每次有数据更新就必须将数据写入到磁盘中，而可以先将最新的数据驻留在磁盘中，等到积累到最后多之后，再使用归并排序的方式将内存内的数据合并追加到磁盘队尾(因为所有待排序的树都是有序的，可以通过合并排序的方式快速合并到一起)。</p>
<p>日志结构的合并树（LSM-tree）是一种基于硬盘的数据结构，与B-tree相比，能显著地减少硬盘磁盘臂的开销，并能在较长的时间提供对文件的高速插入（删除）。然而LSM-tree在某些情况下，特别是在查询需要快速响应时性能不佳。通常LSM-tree适用于索引插入比检索更频繁的应用系统。<strong>Bigtable在提供Tablet服务时，使用GFS来存储日志和SSTable，而GFS的设计初衷就是希望通过添加新数据的方式而不是通过重写旧数据的方式来修改文件</strong>。而LSM-tree通过滚动合并和多页块的方法推迟和批量进行索引更新，充分利用内存来存储近期或常用数据以降低查找代价，利用硬盘来存储不常用数据以减少存储代价。</p>
<p>磁盘的技术特性:对磁盘来说，能够最大化的发挥磁盘技术特性的使用方式是:一次性的读取或写入固定大小的一块数据，并尽可能的减少随机寻道这个操作的次数。</p>
<p>转自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/dbanote/article/details/8897599">http://blog.csdn.net/dbanote/article/details/8897599</a></p>
<p>LSM树是Hbase里非常有创意的一种数据结构，它和传统的B+树不太一样，下面先说说B+树。</p>
<h3 id="1-B-树"><a href="#1-B-树" class="headerlink" title="1 B+树"></a>1 B+树</h3><p>相信大家对B+树已经非常的熟悉，比如Oracle的普通索引就是采用B+树的方式，下面是一个B+树的例子：</p>
<p><img src="http://img.blog.csdn.net/20130508094533796" alt="img"></p>
<p>根节点和枝节点很简单，分别记录每个叶子节点的最小值，并用一个指针指向叶子节点。</p>
<p>叶子节点里每个键值都指向真正的数据块（如Oracle里的RowID），每个叶子节点都有前指针和后指针，这是为了做范围查询时，叶子节点间可以直接跳转，从而避免再去回溯至枝和跟节点。</p>
<p><strong>B+树最大的性能问题是会产生大量的随机IO</strong>，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量读随机IO。</p>
<p>对于大量的随机写也一样，举一个插入key跨度很大的例子，如7-&gt;1000-&gt;3-&gt;2000 … 新插入的数据存储在磁盘上相隔很远，会产生大量的随机写IO.</p>
<p>从上面可以看出，低下的磁盘寻道速度严重影响性能（近些年来，磁盘寻道速度的发展几乎处于停滞的状态）。</p>
<h3 id="2-LSM树"><a href="#2-LSM树" class="headerlink" title="2 LSM树"></a>2 LSM树</h3><p>为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。</p>
<p>为了更好的说明LSM树的原理，下面举个比较极端的例子：</p>
<p>现在假设有1000个节点的随机key，对于磁盘来说，肯定是把这1000个节点顺序写入磁盘最快，但是这样一来，读就悲剧了，因为key在磁盘中完全无序，每次读取都要全扫描；</p>
<p>那么，为了让读性能尽量高，数据在磁盘中必须得有序，这就是B+树的原理，但是写就悲剧了，因为会产生大量的随机IO，磁盘寻道速度跟不上。</p>
<p>LSM树本质上就是在读写之间取得平衡，和B+树相比，<strong>它牺牲了部分读性能，用来大幅提高写性能</strong>。</p>
<p>它的原理是把一颗大树拆分成N棵小树， 它首先写入到内存中（内存没有寻道速度的问题，随机写的性能得到大幅提升），在内存中构建一颗有序小树，随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历所有的小树，但在每颗小树内部数据是有序的。</p>
<p><img src="http://img.blog.csdn.net/20130508094524405" alt="img"></p>
<p>以上就是LSM树最本质的原理，有了原理，再看具体的技术就很简单了。</p>
<p>1）首先说说为什么要有WAL（Write Ahead Log），<strong>很简单，因为数据是先写到内存中，如果断电，内存中的数据会丢失，因此为了保护内存中的数据，需要在磁盘上先记录logfile</strong>，当内存中的数据flush到磁盘上时，就可以抛弃相应的Logfile。</p>
<p>2）什么是memstore, storefile？很简单，上面说过，LSM树就是一堆小树，在内存中的小树即memstore，每次flush，内存中的memstore变成磁盘上一个新的storefile。</p>
<p>3）为什么会有compact？很简单，<strong>随着小树越来越多，读的性能会越来越差，因此需要在适当的时候，对磁盘中的小树进行merge，多棵小树变成一颗大树。</strong></p>
<p>关于LSM Tree，对于最简单的二层LSM Tree而言，内存中的数据和磁盘中的数据merge操作，如下图</p>
<p><img src="/LSM.assets/281219493293115.png" alt="img"></p>
<p>下面说说详细例子:</p>
<p><strong>LSM Tree</strong>弄了很多个小的有序结构，比如每m个数据，在内存里排序一次，下面100个数据，再排序一次……这样依次做下去，就可以获得N&#x2F;m个有序的小的有序结构。</p>
<p>在查询的时候，因为不知道这个数据到底是在哪里，所以就从最新的一个小的有序结构里做二分查找，找得到就返回，找不到就继续找下一个小有序结构，一直到找到为止。</p>
<p>很容易可以看出，这样的模式，读取的时间复杂度是(N&#x2F;m)*log2N 。读取效率是会下降的。</p>
<p>这就是最本来意义上的LSM tree的思路。那么这样做，性能还是比较慢的，于是需要再做些事情来提升，怎么做才好呢？</p>
<p><strong>LSM Tree优化方式：</strong></p>
<p>a、Bloom filter: 就是个带随即概率的bitmap,可以快速的告诉你，某一个小的有序结构里有没有指定的那个数据的。于是就可以不用二分查找，而只需简单的计算几次就能知道数据是否在某个小集合里啦。效率得到了提升，但付出的是空间代价。</p>
<p>b、compact:小树合并为大树:因为小树他性能有问题，所以要有个进程不断地将小树合并到大树上，这样大部分的<strong>老数据</strong>查询也可以直接使用log2N的方式找到，不需要再进行(N&#x2F;m)*log2n的查询了</p>
<p>更详细的可以参考：<a target="_blank" rel="noopener" href="http://weakyon.com/2015/04/08/Log-Structured-Merge-Trees.html">http://weakyon.com/2015/04/08/Log-Structured-Merge-Trees.html</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/shenfentyin">Shen Fengyin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://shenfenyin.github.io/2024/01/15/LSM/">http://shenfenyin.github.io/2024/01/15/LSM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://shenfenyin.github.io" target="_blank">SHENFY BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LSM/">LSM</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/sfy_portriat.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/15/new-UUID/" title="新版雪花算法的理解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">新版雪花算法的理解</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/15/hexo-butterfly/" title="使用hexo搭建离线博客"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">使用hexo搭建离线博客</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/sfy_portriat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Shen Fengyin</div><div class="author-info__description">记录博主日常学习记录，包括后端、大数据相关开发知识，后续会陆续更新机器学习的部分~~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/shenfengyin"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/shenfengyin" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:shenfy@stu.pku.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">博客内容更新-ing</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E8%BD%BD-LSM%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">[转载]LSM树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LSM%E6%A0%91%E8%AF%9E%E7%94%9F%E8%83%8C%E6%99%AF"><span class="toc-number">1.0.1.</span> <span class="toc-text">LSM树诞生背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%A3%81%E7%9B%98IO"><span class="toc-number">1.0.2.</span> <span class="toc-text">关于磁盘IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LSM%E6%A0%91%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.3.</span> <span class="toc-text">LSM树原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.0.4.</span> <span class="toc-text">插入步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.0.5.</span> <span class="toc-text">合并步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BC%98%E5%8C%96%E6%8E%AA%E6%96%BD"><span class="toc-number">1.0.6.</span> <span class="toc-text">关于优化措施</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">1.0.7.</span> <span class="toc-text">插入操作-实例演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.8.</span> <span class="toc-text">查找操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.9.</span> <span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">二次介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LSM%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.1.</span> <span class="toc-text">LSM操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LSM-VS-B%E6%A0%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">LSM VS B树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hbase-VS-kudu-%E5%BE%85%E3%80%82%E3%80%82%E3%80%82"><span class="toc-number">1.1.3.</span> <span class="toc-text">Hbase VS kudu  待。。。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E6%A0%B7%E7%9C%8B%E6%9D%A5%EF%BC%8C%E4%BB%8EB%E6%A0%91%E5%88%B0LSM%EF%BC%8C%E5%88%B0kudu%E5%AF%B9LSM%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%8C%E5%85%B6%E5%AE%9E%E9%83%BD%E6%98%AF%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8D%E5%90%8C%E7%9A%84%E8%AE%BF%E9%97%AE%E9%9C%80%E6%B1%82%E5%81%9A%E5%87%BA%E7%9A%84%E5%90%84%E7%A7%8D%E6%9D%83%E8%A1%A1%E8%80%8C%E5%B7%B2%E3%80%82%E4%BA%86%E8%A7%A3%E4%BA%86%E8%BF%99%E4%BA%9B%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E9%80%89%E6%8B%A9%E8%BF%99%E4%BA%9B%E6%8A%80%E6%9C%AF%E7%9A%84%E6%97%B6%E5%80%99%E5%BF%83%E9%87%8C%E5%B0%B1%E6%9C%89%E5%BA%95%E4%BA%86%E3%80%82%E5%8F%A6%E5%A4%96%EF%BC%8C%E6%9D%83%E8%A1%A1%E5%B9%B6%E4%B8%8D%E6%98%AF%E9%82%A3%E4%B9%88%E5%AE%B9%E6%98%93%E7%9A%84%E4%BA%8B%E3%80%82%E6%80%8E%E4%B9%88%E6%A0%B7%E7%89%BA%E7%89%B2A%E5%8E%BB%E8%A1%A5%E5%81%BFB%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E7%AD%96%E7%95%A5%E3%80%82%E7%A0%94%E7%A9%B6%E7%8E%B0%E6%9C%89%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E6%83%B3%EF%BC%8C%E6%9C%89%E5%8A%A9%E4%BA%8E%E5%BD%93%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E9%9D%A2%E4%B8%B4%E9%97%AE%E9%A2%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%9C%89%E6%9B%B4%E5%A4%9A%E6%80%9D%E8%B7%AF%E3%80%82"><span class="toc-number">1.1.4.</span> <span class="toc-text">这样看来，从B树到LSM，到kudu对LSM的优化，其实都是针对不同场景不同的访问需求做出的各种权衡而已。了解了这些，我们在选择这些技术的时候心里就有底了。另外，权衡并不是那么容易的事。怎么样牺牲A去补偿B，可能有不同的策略。研究现有系统的一些思想，有助于当我们自己面临问题的时候，有更多思路。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-B-%E6%A0%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">1 B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-LSM%E6%A0%91"><span class="toc-number">1.2.2.</span> <span class="toc-text">2 LSM树</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/new-UUID/" title="新版雪花算法的理解">新版雪花算法的理解</a><time datetime="2024-01-14T16:51:57.855Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/LSM/" title="LSM学习">LSM学习</a><time datetime="2024-01-14T16:51:57.852Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/hexo-butterfly/" title="使用hexo搭建离线博客">使用hexo搭建离线博客</a><time datetime="2024-01-14T16:51:57.848Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/git-command/" title="Git命令介绍">Git命令介绍</a><time datetime="2024-01-14T16:51:57.846Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/flink-frame/" title="Flink运行时架构">Flink运行时架构</a><time datetime="2024-01-14T16:51:57.843Z" title="发表于 2024-01-15 00:51:57">2024-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Shen Fengyin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">身体健康，吃好喝好~.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>